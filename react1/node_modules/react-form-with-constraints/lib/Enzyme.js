"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("./index");
var Bootstrap4 = require("./Bootstrap4");
// Return the list of FieldFeedback associated with an input name
// Algorithm: find the FieldFeedbacks that matches the input name (for prop) and then return its children
function findFieldFeedbackList(wrapper, inputName) {
    var fieldFeedbacksList = wrapper.findWhere(function (node) {
        var found = false;
        if (node.type() === index_1.FieldFeedbacks || node.type() === Bootstrap4.FieldFeedbacks) {
            if (node.prop('for') === inputName) {
                found = true;
            }
        }
        return found;
    });
    // No use of expect() otherwise it mess up with expect.assertions(N)
    console.assert(fieldFeedbacksList.length >= 1, 'At least 1 FieldFeedbacks should match');
    var fieldFeedbackList = fieldFeedbacksList.findWhere(function (node) {
        var found = false;
        if (node.type() === index_1.FieldFeedback) {
            found = true;
        }
        return found;
    });
    // No use of expect() otherwise it mess up with expect.assertions(N)
    console.assert(fieldFeedbacksList.length >= 1, 'At least 1 FieldFeedback');
    return fieldFeedbackList;
}
function getFieldFeedbacksMessages(inputs) {
    var messages = [];
    inputs.forEach(function (input) {
        var _a = input.props(), name = _a.name, value = _a.value;
        var fieldFeedbackList = findFieldFeedbackList(input.parent(), name);
        fieldFeedbackList.forEach(function (fieldFeedback) {
            var _a = fieldFeedback.props(), when = _a.when, children = _a.children;
            if (typeof when === 'function') {
                var constraintViolation = when(value);
                if (constraintViolation) {
                    messages.push(children);
                }
            }
            else if (typeof when === 'string') {
                var validationMessage = simulateHTML5InputValidation(input.props(), when);
                if (validationMessage !== undefined) {
                    if (children === undefined) {
                        messages.push(validationMessage);
                    }
                    else {
                        messages.push(children);
                    }
                }
            }
            else {
                console.assert(false, "Invalid FieldFeedback 'when': " + when);
            }
        });
    });
    return messages;
}
exports.getFieldFeedbacksMessages = getFieldFeedbacksMessages;
// See HTML5 Form Shim https://github.com/dsheiko/HTML5-Form-Shim
// See https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#web-forms
// See https://github.com/MrSwitch/jquery.form.js/blob/48e576db6c0114fe997ac549d074f87be06f54f3/src/jquery.checkValidity.js
function simulateHTML5InputValidation(input, when) {
    // input.validationMessage
    // See https://developer.mozilla.org/en/docs/Web/API/HTMLInputElement
    // See https://www.w3.org/TR/html51/sec-forms.html#the-constraint-validation-api
    var validationMessage;
    switch (when) {
        case '*':
            // Order is important
            validationMessage = valueMissing(input);
            if (validationMessage === undefined)
                validationMessage = typeMismatch(input);
            if (validationMessage === undefined)
                validationMessage = tooShort(input);
            if (validationMessage === undefined)
                validationMessage = tooLong(input);
            if (validationMessage === undefined)
                validationMessage = stepMismatch(input);
            if (validationMessage === undefined)
                validationMessage = rangeUnderflow(input);
            if (validationMessage === undefined)
                validationMessage = rangeOverflow(input);
            if (validationMessage === undefined)
                validationMessage = patternMismatch(input);
            if (validationMessage === undefined)
                validationMessage = badInput(input);
            break;
        case 'badInput':
            validationMessage = badInput(input);
            break;
        case 'patternMismatch':
            validationMessage = patternMismatch(input);
            break;
        case 'rangeOverflow':
            validationMessage = rangeOverflow(input);
            break;
        case 'rangeUnderflow':
            validationMessage = rangeUnderflow(input);
            break;
        case 'stepMismatch':
            validationMessage = stepMismatch(input);
            break;
        case 'tooLong':
            validationMessage = tooLong(input);
            break;
        case 'tooShort':
            validationMessage = tooShort(input);
            break;
        case 'typeMismatch':
            validationMessage = typeMismatch(input);
            break;
        case 'valueMissing':
            validationMessage = valueMissing(input);
            break;
        default:
            console.assert(false, "Invalid FieldFeedback 'when': " + when);
    }
    return validationMessage;
}
function badInput(input) {
    var validationMessage;
    if (input.type === 'number' && isNaN(input.value)) {
        validationMessage = 'Please enter a number.';
    }
    return validationMessage;
}
function patternMismatch(input) {
    var value = input.value;
    var validationMessage;
    if (input.pattern !== undefined && !new RegExp('^' + input.pattern + '$').test(value)) {
        validationMessage = 'Please match the requested format.';
    }
    return validationMessage;
}
function rangeOverflow(input) {
    var value = input.value;
    var max = input.max;
    var validationMessage;
    if (max !== undefined && value > max) {
        validationMessage = "Value must be less than or equal to " + max + ".";
    }
    return validationMessage;
}
function rangeUnderflow(input) {
    var value = input.value;
    var min = input.min;
    var validationMessage;
    if (min !== undefined && value < min) {
        validationMessage = "Value must be greater than or equal to " + min + ".";
    }
    return validationMessage;
}
function stepMismatch(input) {
    var value = input.value;
    var step = input.step;
    var validationMessage;
    if (step !== undefined && value % step) {
        validationMessage = 'Please enter a valid value.';
    }
    return validationMessage;
}
function tooLong(input) {
    var value = input.value;
    var maxLength = input.maxLength;
    var validationMessage;
    if (maxLength !== undefined && value.length > maxLength) {
        validationMessage = "Please lengthen this text to " + maxLength + " characters or less.";
    }
    return validationMessage;
}
function tooShort(input) {
    var value = input.value;
    var minLength = input.minLength;
    var validationMessage;
    if (minLength !== undefined && value.length < minLength) {
        validationMessage = "Please lengthen this text to " + minLength + " characters or more.";
    }
    return validationMessage;
}
function typeMismatch(input) {
    var value = input.value;
    var validationMessage;
    if (input.type === 'email' && !/\S+@\S+/.test(value)) {
        validationMessage = 'Please enter an email address.';
    }
    else if (input.type === 'url' && !/^https?\:\/\/[a-z0-9]+/i.test(value)) {
        validationMessage = 'Please enter a URL.';
    }
    return validationMessage;
}
function valueMissing(input) {
    var value = input.value;
    var validationMessage;
    if (input.required === true && value.length === 0) {
        validationMessage = 'Please fill out this field.';
    }
    return validationMessage;
}
//# sourceMappingURL=Enzyme.js.map